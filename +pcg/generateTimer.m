function generateTimer(varargin)
    p = inputParser;
    p.addParameter('dir', './gen', @ischar);
    p.addParameter('overwrite', false, @islogical);
    p.parse(varargin{:});
    options = p.Results;
    
    if ~options.overwrite && exist([options.dir '/timer.h'],'file') && exist([options.dir '/timer.c'],'file')
        return;
    end
    
     % Generate file for timings
    code = ['#ifndef _TIMER_H_\n' ...
            '#define _TIMER_H_\n\n' ...
            '#if defined (_WIN32) || defined (_WIN64) /* Windows */\n' ...
            '\t' '#include <windows.h>\n\n' ...
            '\t' 'typedef struct {\n' ...
            '\t' '\t' 'LARGE_INTEGER start;\n' ...
            '\t' '\t' 'LARGE_INTEGER stop;\n'...
            '\t' '\t' 'LARGE_INTEGER freq;\n' ...
            '\t' '} timer;\n' ...
            '#elif defined (__APPLE__) && defined (__MACH__) /* Mac */\n' ...
            '/* Reference: https://developer.apple.com/library/mac/qa/qa1398/_index.html */\n' ...
            '\t' '#include <mach/mach_time.h>\n\n' ...
            '\t' '#define TIMER_NANOTOSEC (1.0/1e9)\n\n' ...
            '\t' 'typedef struct {\n' ...
            '\t' '\t' 'uint64_t start;\n' ...
            '\t' '\t' 'uint64_t stop;\n'...
            '\t' '\t' 'double toSeconds;\n' ...
            '\t' '} timer;\n' ...
            '#else /* Unix */\n' ...
            '\t' '#include <time.h>\n' ...
            '\t' '#include <sys/time.h>\n\n' ...
            '\t' '#define TIMER_SECTONANO (1e9)\n' ... 
            '\t' '#define TIMER_NANOTOSEC (1.0/TIMER_SECTONANO)\n\n' ...
            '\t' 'typedef struct {\n' ...
            '\t' '\t' 'struct timespec start;\n' ...
            '\t' '\t' 'struct timespec stop;\n' ...
            '\t' '} timer;\n' ...
            '#endif\n\n' ...
            'void timer_init(timer* t);\n' ...
            'void timer_start(timer* t);\n' ...
            'double timer_stop(timer* t);\n' ...
            '\n\n#endif /* _TIMER_H_ */'];
    f = fopen([options.dir '/timer.h'], 'w');
    fprintf(f, code);
    fclose(f);
    code = ['#include "timer.h"\n\n' ...
        '#if defined (_WIN32) || defined (_WIN64) /* Windows */\n' ...
        '\t' 'void timer_init(timer* t) {\n' ...
        '\t' '\t' 'QueryPerformanceFrequency(&(t->freq)); } /* Initialize frequency */\n' ...
        '\t' 'void timer_start(timer* t) {\n' ...
        '\t' '\t' 'QueryPerformanceCounter(&(t->start)); }' ...
        '\t' 'double timer_stop(timer* t) {\n' ...
        '\t' '\t' 'QueryPerformanceCounter(&(t->stop));\n' ...
        '\t' '\t' 'return (t->stop - t->start) / (double) frequency.QuadPart);\n' ...
        '#elif defined (__MACH__) /* Mac */\n' ...
        '\t' 'void timer_init(timer* t) {\n' ...
        '\t' '\t' 'mach_timebase_info_data_t info;\n' ...
        '\t' '\t' '(void) mach_timebase_info(&info); } /* Get time base */\n' ...
        '\t' '\t' 't->toSeconds = TIMER_NANOTOSEC * (double)(info.numer / info.denom);\n' ...
        '\t' 'void timer_start(timer* t) {\n' ...
        '\t' '\t' 't->start = mach_absolute_time(); }\n' ...
        '\t' 'double timer_stop(timer* t) {\n' ...
        '\t' '\t' 't->stop = mach_absolute_time();\n' ...
        '\t' '\t' 'return (double)(t->stop-t->start) * t->toSeconds;\n' ...
        '\t' '};\n' ...
        '#else /* Unix */\n' ...
        '\t' 'void timer_init(timer* t) { }\n' ...
        '\t' 'void timer_start(timer* t) {\n' ...
        '\t' '\t' 'clock_gettime(CLOCK_MONOTONIC, &(t->start)); }\n' ...
        '\t' 'double timer_stop(timer* t) {\n' ...
        '\t' '\t' 'clock_gettime(CLOCK_MONOTONIC, &(t->stop));\n' ...
        '\t' '\t' 'if(t->stop.tv_nsec < t->start.tv_nsec) { /* Overflow occurred */\n' ...
        '\t' '\t' '\t' 'return (double)(t->stop.tv_sec - t->start.tv_sec)-1.0 + ((double)(t->stop.tv_nsec - t->start.tv_nsec) + TIMER_SECTONANO)*TIMER_NANOTOSEC; }\n' ...
        '\t' '\t' 'return (double)(t->stop.tv_sec - t->start.tv_sec) + ((double)(t->stop.tv_nsec - t->start.tv_nsec))*TIMER_NANOTOSEC;\n' ...
        '\t' '};\n' ...
        '#endif\n'];
    f = fopen([options.dir '/timer.c'], 'w');
    fprintf(f, code);
    fclose(f);

end