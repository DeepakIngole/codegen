% GENERATEPROXCODE Generate a fixed-point iteration .mex file
% 
% generateProxCode(model, 'par1', val1, 'par2', val2, ...)
% 

function generateProxCode(varargin)
    p = inputParser;
    p.addRequired('M', @isnumeric);
    p.addRequired('W', @isnumeric);
    p.addRequired('nr', @isnumeric);
    p.addParameter('stepSize', 0.5, @(x)(isnumeric(x) && x > 0 && x < 1));
    p.addParameter('maxIt', 1000, @(x)(isnumeric(x) && length(x) == 1 && x > 0 && mod(x,1) == 0)); % Maximum number of iterations
    p.addParameter('ctol', 1e-3, @(x)(isnumeric(x) && length(x) == 1 && x >= eps)); % Consensus tolerance
    p.addParameter('stoppingCriterion', 'consensus', @(s)(any(strcmp(s,{'consensus', 'maxIt'})))); % Stopping criterion
    p.addParameter('stopOnThreshold', true, @islogical);
    p.addParameter('gendir', './gen', @ischar);
    p.addParameter('verbose', 0, @isnumeric);
    p.addParameter('test', 0, @isnumeric);
    p.addParameter('solverName', 'hybridMPC', @ischar); % Name of generated solver
    p.parse(varargin{:});
    options = p.Results;
    
    if options.verbose >= 1
        display('Generating embedded fixed-point iteration...');
    end
    
    dim = size(M,1);
    
    [Mdata, Mcode] = pcg.generateMVMult(options.M, [upper(options.solverName) '_M'], 'a', 'r', 'sym', true, 'nDataTabs', 0, 'nCodeTabs', 1);
    [gWdata, gWcode] = pcg.generateMVMult(options.stepSize*options.W, [upper(options.solverName) '_gW'], 'a', 'r', 'sym', true, 'nDataTabs', 0, 'nCodeTabs', 1);
    
    % Generate file for timings
    code = ['#ifndef _TIMER_H_\n' ...
            '#define _TIMER_H_\n\n' ...
            '#if defined (_WIN32) || defined (_WIN64) /* Windows */\n' ...
            '\t' '#include <windows.h>\n\n' ...
            '\t' 'typedef struct {\n' ...
            '\t' '\t' 'LARGE_INTEGER start;\n' ...
            '\t' '\t' 'LARGE_INTEGER stop;\n'...
            '\t' '\t' 'LARGE_INTEGER freq;\n' ...
            '\t' '} timer;\n' ...
            '#elif defined (__APPLE__) && defined (__MACH__) /* Mac */\n' ...
            '/* Reference: https://developer.apple.com/library/mac/qa/qa1398/_index.html */\n' ...
            '\t' '#include <mach/mach_time.h>\n\n' ...
            '\t' '#define TIMER_NANOTOSEC (1.0/1e9)\n\n' ...
            '\t' 'typedef struct {\n' ...
            '\t' '\t' 'uint64_t start;\n' ...
            '\t' '\t' 'uint64_t stop;\n'...
            '\t' '\t' 'double toSeconds;\n' ...
            '\t' '} timer;\n' ...
            '#else /* Unix */\n' ...
            '\t' '#include <time.h>\n' ...
            '\t' '#include <sys/time.h>\n\n' ...
            '\t' '#define TIMER_SECTONANO (1e9)\n' ... 
            '\t' '#define TIMER_NANOTOSEC (1.0/TIMER_SECTONANO)\n\n' ...
            '\t' 'typedef struct {\n' ...
            '\t' '\t' 'struct timespec start;\n' ...
            '\t' '\t' 'struct timespec stop;\n' ...
            '\t' '} timer;\n' ...
            '#endif\n\n' ...
            'void timer_init(timer* t);\n' ...
            'void timer_start(timer* t);\n' ...
            'double timer_stop(timer* t);\n' ...
            '\n\n#endif /* _TIMER_H_ */'];
    f = fopen([options.gendir '/timer.h'], 'w');
    fprintf(f, code);
    fclose(f);
    code = ['#include "timer.h"\n\n' ...
        '#if defined (_WIN32) || defined (_WIN64) /* Windows */\n' ...
        '\t' 'void timer_init(timer* t) {\n' ...
        '\t' '\t' 'QueryPerformanceFrequency(&(t->freq)); } /* Initialize frequency */\n' ...
        '\t' 'void timer_start(timer* t) {\n' ...
        '\t' '\t' 'QueryPerformanceCounter(&(t->start)); }' ...
        '\t' 'double timer_stop(timer* t) {\n' ...
        '\t' '\t' 'QueryPerformanceCounter(&(t->stop));\n' ...
        '\t' '\t' 'return (t->stop - t->start) / (double) frequency.QuadPart);\n' ...
        '#elif defined (__MACH__) /* Mac */\n' ...
        '\t' 'void timer_init(timer* t) {\n' ...
        '\t' '\t' 'mach_timebase_info_data_t info;\n' ...
        '\t' '\t' '(void) mach_timebase_info(&info); } /* Get time base */\n' ...
        '\t' '\t' 't->toSeconds = TIMER_NANOTOSEC * (double)(info.numer / info.denom);\n' ...
        '\t' 'void timer_start(timer* t) {\n' ...
        '\t' '\t' 't->start = mach_absolute_time(); }\n' ...
        '\t' 'double timer_stop(timer* t) {\n' ...
        '\t' '\t' 't->stop = mach_absolute_time();\n' ...
        '\t' '\t' 'return (double)(t->stop-t->start) * t->toSeconds;\n' ...
        '\t' '};\n' ...
        '#else /* Unix */\n' ...
        '\t' 'void timer_init(timer* t) { }\n' ...
        '\t' 'void timer_start(timer* t) {\n' ...
        '\t' '\t' 'clock_gettime(CLOCK_MONOTONIC, &(t->start)); }\n' ...
        '\t' 'double timer_stop(timer* t) {\n' ...
        '\t' '\t' 'clock_gettime(CLOCK_MONOTONIC, &(t->stop));\n' ...
        '\t' '\t' 'if(t->stop.tv_nsec < t->start.tv_nsec) { /* Overflow occurred */\n' ...
        '\t' '\t' '\t' 'return (double)(t->stop.tv_sec - t->start.tv_sec)-1.0 + ((double)(t->stop.tv_nsec - t->start.tv_nsec) + TIMER_SECTONANO)*TIMER_NANOTOSEC; }\n' ...
        '\t' '\t' 'return (double)(t->stop.tv_sec - t->start.tv_sec) + ((double)(t->stop.tv_nsec - t->start.tv_nsec))*TIMER_NANOTOSEC;\n' ...
        '\t' '};\n' ...
        '#endif\n'];
    f = fopen([options.gendir '/timer.c'], 'w');
    fprintf(f, code);
    fclose(f);
    
    % Generate fixed-point iteration C-file
    f = fopen([options.gendir '/project.h'], 'rt');
    code = fread(f, inf, 'char=>char');
    fclose(f);
    code = strrep(code', '_PROJECT_H_', ['_' upper(options.solverName) '_H_']);
    f = fopen([options.gendir '/' options.solverName '.h'], 'w');
    fprintf(f, code);
    fclose(f);
    f = fopen([options.gendir '/project.c'], 'rt');
    code = fread(f, inf, 'char=>char');
    fclose(f);
    code = strrep(code', 'x', 's');
    code = strrep(code, 'project.h', [options.solverName '.h"\n#include "timer.h']);
    code = strrep(code, 'mes', 'mex');
    code = strrep(code, 'ms', 'mx');
    code = strrep(code, 'Matris', 'Matrix');
    code = strrep(code, 'double* s = mxGetPr', 'double* x = mxGetPr');
    data = [Mdata '\n\n' gWdata '\n\n'];
    code = strrep(code, '/* Helper functions */', ['timer T;\n\n' data '\n/* Helper functions */']);
    code = regexprep(code, '(/. Helper functions ./.*)\nvoid', ['$0 ' ...
        'vadd(double* a, double* b, unsigned int n, double* r) { /* r = a + b */\n' ...
        '\t' 'unsigned int i;\n' ...
        '\t' 'for(i=0; i<n; i++) {\n' ...
        '\t' '\t' 'r[i] = a[i]+b[i];' ...
        '\t' '}\n' ...
        '}\n' ...
        'void vsub(double* a, double* b, unsigned int n, double* r) { /* r = a - b */\n' ...
        '\t' 'unsigned int i;\n' ...
        '\t' 'for(i=0; i<n; i++) {\n' ...
        '\t' '\t' 'r[i] = a[i]-b[i];' ...
        '\t' '}\n' ...
        '}\n\n' ...
        'void mvmul' upper(options.solverName) '_M(double* a, unsigned int n, double* r) { /* r = r + ' upper(options.solverName) '_M*a */\n' ...
        Mcode ...
        '}\n' ...
        'void mvmul' upper(options.solverName) '_gW(double* a, unsigned int n, double* r) { /* r = r + ' upper(options.solverName) '_gW*a */\n' ...
        gWcode ...
        '}\n\n' ...
        'double twonormsq(double* a, unsigned int n) { /* |a|^2 */\n' ...
        '\t' 'unsigned int i;\n' ...
        '\t' 'double norm = 0.0;\n' ...
        '\t' 'for(i=0; i<n; i++) {\n' ...
        '\t' '\t' 'norm = norm + a[i]*a[i];' ...
        '\t' '}\n' ...
        '\t' 'return norm;\n' ...
        '}\n\n' ...
        'void']);
    code = strrep(code, 'double* theta = mxGetPr(prhs[1]);', 'double* theta = mxGetPr(prhs[1]);\n\tdouble* c = mxGetPr(prhs[2]);');
    code = strrep(code, ['plhs[0] = mxCreateDoubleMatrix(' dim ',1,mxREAL);'], ['plhs[0] = mxCreateDoubleMatrix(' dim ',1,mxREAL);\n\tplhs[1] = mxCreateDoubleMatrix(' dim ',1,mxREAL);\n\tplhs[2] = mxCreateDoubleMatrix(' dim ',1,mxREAL);\n\tplhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);\n\tplhs[4] = mxCreateDoubleMatrix(1,1,mxREAL);']);
    code = strrep(code, 'double* z = mxGetPr(plhs[0]);', ['double* y = mxGetPr(plhs[0]);\n\tdouble* z = mxGetPr(plhs[1]);\n\tdouble* s = mxGetPr(plhs[2]);\n\tdouble* nIt = mxGetPr(plhs[3]);\n\tdouble* t = mxGetPr(plhs[4]);\n\tdouble d[' dim '];']);
    code = strrep(code, '/* Initial state */', [ ...
        'unsigned int it = 1;\n' ...
        '\t' 'timer_init(&T);\n' ...
        '\t' 'timer_start(&T);\n' ...
        '\t' 'vcopy(x, ' dim ', s);\n' ...
        '\t' 'while(1) {\n' ...
        '\t' '/* AFFINE MAP (1st step) */\n' ...
        '\t' 'vcopy(c, ' dim ', y);/* y = c */\n' ...
        '\t' 'mvmul' upper(options.solverName) '_M(s, ' dim ', y); /* y = y + Ms = Ms+c */\n\n' ...
        '\t' '/* PROJECTION (2nd step) */\n\t/* Initial state */']);
    repStr = ['$0\n\n' ...
        '\t' '/* S-UPDATE (3rd step) */\n' ...
        '\t' 'vsub(z, y, ' dim ', d); /* d = z-y = -(y-z) */\n' ...
        '\t' 'mvmul' upper(options.solverName) '_gW(d, ' dim ', s); /* s = s + gWd = s - gW(y-z) */\n' ...
        '\n'];
    switch options.stoppingCriterion
        case 'consensus',
            repStr = [repStr ...
            '\t' '/* CONSENSUS VIOLATION AND MAX ITERATION CHECK */\n' ...
            '\t' 'if(twonormsq(d, ' dim ') <= ' sprintf('%0.10g', options.ctol^2) ' || it >= ' sprintf('%d', options.maxIt) ') {\n'];
        case 'maxIt'
            repStr = [repStr ...
            '\t' '/* MAX ITERATION CHECK */\n' ...
            '\t' 'if(it >= ' sprintf('%d', options.maxIt) ') {\n'];
    end
    repStr = [repStr ...
        '\t' '\tnIt[0] = it;\n' ...
        '\t' '\tt[0] = timer_stop(&T);\n' ...
        '\t' '\tbreak;\n' ...
        '\t' '}\n' ...
        '\t' 'it = it+1;\n'];
    if options.verbose >= 2
        repStr = [repStr '\tmexPrintf(''Consensus violation: %0.5g'', twonormsq(d, ' dim '));\n'];
    end
        repStr = [repStr '\t}'];
    code = regexprep(code, '(/. Final state ./.*\t\t\t})', repStr);
    f = fopen([options.gendir '/' options.solverName '.c'], 'w');
    fprintf(f, code);
    fclose(f);    
    
    if options.verbose >= 1
        display('C-code, done. Compiling...');
    end
    % Compile
    if options.verbose >= 2
        compile = 'mex -v';
    else
        compile = 'mex';
    end
    compile = [compile ' -I"' options.gendir '" CFLAGS="$CFLAGS -Wall" ' options.gendir '/' options.solverName '.c ' options.gendir '/timer.c'];
    for i=1:options.nr
        compile = [compile ' ' options.gendir '/stdproj' num2str(i) '.c'];
        compile = [compile ' ' options.gendir '/iniproj' num2str(i) '.c'];
        compile = [compile ' ' options.gendir '/finproj' num2str(i) '.c'];
    end
    compile = [compile ' -outdir ' options.gendir];
    display(compile);
    eval(compile);
    if options.verbose >= 1
        display('...done.');
    end

end

