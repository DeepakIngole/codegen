% GENERATEPROXCODE Generate a fixed-point iteration .mex file
% 
% generateProxCode(model, 'par1', val1, 'par2', val2, ...)
% 

function generateProxCode(varargin)
    p = inputParser;
    p.addRequired('M', @isnumeric);
    p.addRequired('W', @isnumeric);
    p.addRequired('nr', @isnumeric);
    p.addParameter('stepSize', 0.5, @(x)(isnumeric(x) && x > 0 && x < 1));
    p.addParameter('maxIt', 1000, @isnumeric);
    p.addParameter('eps', eps, @(x)(isnumeric(x) && x >= eps));
    p.addParameter('stopOnThreshold', true, @islogical);
    p.addParameter('gendir', './gen', @ischar);
    p.addParameter('verbose', 0, @isnumeric);
    p.addParameter('test', 0, @isnumeric);
    p.parse(varargin{:});
    options = p.Results;
    
    if options.verbose >= 1
        display('Generating embedded fixed-point iteration...');
    end
    
    [Mdata, Mcode] = pcg.generateMVMult(options.M, 'PROX_M', 'a', 'r', 'sym', true, 'nDataTabs', 0, 'nCodeTabs', 1);
    [gWdata, gWcode] = pcg.generateMVMult(options.stepSize*options.W, 'PROX_gW', 'a', 'r', 'sym', true, 'nDataTabs', 0, 'nCodeTabs', 1);
    
    copyfile('+proxop/timer.h', [options.gendir '/timer.h']);
    f = fopen([options.gendir '/timer.h'], 'rt');
    code = fread(f, inf, 'char=>char');
    fclose(f);
    code = strrep(code', '#include "glblopts.h"', '#define PROFILING (1)\n\ntypedef double pfloat;\n');
    f = fopen([options.gendir '/timer.h'], 'w');
    fprintf(f, code);
    fclose(f);
    copyfile('+proxop/timer.c', [options.gendir '/timer.c']);
    
    % Generate fixed-point iteration C-file
    f = fopen([options.gendir '/project.h'], 'rt');
    code = fread(f, inf, 'char=>char');
    fclose(f);
    code = strrep(code', '_PROJECT_H_', '_EPROX_H_');
    f = fopen([options.gendir '/eprox.h'], 'w');
    fprintf(f, code);
    fclose(f);
    f = fopen([options.gendir '/project.c'], 'rt');
    code = fread(f, inf, 'char=>char');
    fclose(f);
    dim = regexp(code', 'plhs... = mxCreateDoubleMatrix.(\d+),1,mxREAL.;', 'tokens');
    dim = dim{1}{1};
    n = str2num(dim);
    code = strrep(code', 'x', 's');
    code = strrep(code, 'project.h', 'eprox.h"\n#include "timer.h');
    code = strrep(code, 'mes', 'mex');
    code = strrep(code, 'ms', 'mx');
    code = strrep(code, 'Matris', 'Matrix');
    code = strrep(code, 'double* s = mxGetPr', 'double* x = mxGetPr');
    data = [Mdata '\n\n' gWdata '\n\n'];
    code = strrep(code, '/* Helper functions */', ['timer T;\n\n' data '\n/* Helper functions */']);
    code = regexprep(code, '(/. Helper functions ./.*)\nvoid', ['$0 ' ...
        'vadd(double* a, double* b, unsigned int n, double* r) { /* r = a + b */\n' ...
        '\tunsigned int i;\n' ...
        '\tfor(i=0; i<n; i++) {\n' ...
        '\t\tr[i] = a[i]+b[i];' ...
        '\t}\n' ...
        '}\n' ...
        'void vsub(double* a, double* b, unsigned int n, double* r) { /* r = a - b */\n' ...
        '\tunsigned int i;\n' ...
        '\tfor(i=0; i<n; i++) {\n' ...
        '\t\tr[i] = a[i]-b[i];' ...
        '\t}\n' ...
        '}\n\n' ...
        'void mvmulPROX_M(double* a, unsigned int n, double* r) { /* r = r + PROX_M*a */\n' ...
        Mcode ...
        '}\n' ...
        'void mvmulPROX_gW(double* a, unsigned int n, double* r) { /* r = r + PROX_gW*a */\n' ...
        gWcode ...
        '}\n\n' ...
        'double twonormsq(double* a, unsigned int n) { /* |a|^2 */\n' ...
        '\tunsigned int i;\n' ...
        '\tdouble norm = 0.0;\n' ...
        '\tfor(i=0; i<n; i++) {\n' ...
        '\t\tnorm = norm + a[i]*a[i];' ...
        '\t}\n' ...
        '\treturn norm;\n' ...
        '}\n\n' ...
        'void']);
    code = strrep(code, 'double* theta = mxGetPr(prhs[1]);', 'double* theta = mxGetPr(prhs[1]);\n\tdouble* c = mxGetPr(prhs[2]);');
    code = strrep(code, ['plhs[0] = mxCreateDoubleMatrix(' dim ',1,mxREAL);'], ['plhs[0] = mxCreateDoubleMatrix(' dim ',1,mxREAL);\n\tplhs[1] = mxCreateDoubleMatrix(' dim ',1,mxREAL);\n\tplhs[2] = mxCreateDoubleMatrix(' dim ',1,mxREAL);\n\tplhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);\n\tplhs[4] = mxCreateDoubleMatrix(1,1,mxREAL);']);
    code = strrep(code, 'double* z = mxGetPr(plhs[0]);', ['double* y = mxGetPr(plhs[0]);\n\tdouble* z = mxGetPr(plhs[1]);\n\tdouble* s = mxGetPr(plhs[2]);\n\tdouble* nIt = mxGetPr(plhs[3]);\n\tdouble* t = mxGetPr(plhs[4]);\n\tdouble d[' dim '];']);
    code = strrep(code, '/* Initial state */', [ ...
        'unsigned int it = 1;\n' ...
        '\ttic(&T);\n' ...
        '\tvcopy(x, ' dim ', s);\n' ...
        '\twhile(1) {\n' ...
        '\t/* AFFINE MAP (1st step) */\n' ...
        '\tvcopy(c, ' dim ', y);/* y = c */\n' ...
        '\tmvmulPROX_M(s, ' dim ', y); /* y = y + Ms = Ms+c */\n\n' ...
        '\t/* PROJECTION (2nd step) */\n\t/* Initial state */']);
    repStr = ['$0\n\n' ...
        '\t/* S-UPDATE (3rd step) */\n' ...
        '\tvsub(z, y, ' dim ', d); /* d = z-y = -(y-z) */\n' ...
        '\tmvmulPROX_gW(d, ' dim ', s); /* s = s + gWd = s - gW(y-z) */\n' ...
        '\n'];
    if options.stopOnThreshold
        repStr = [repStr ...
        '\t/* CONSENSUS VIOLATION AND MAX ITERATION CHECK */\n' ...
        '\tif(twonormsq(d, ' dim ') <= ' sprintf('%0.10g', options.eps^2) ' || it >= ' sprintf('%d', options.maxIt) ') {\n'];
    else
        repStr = [repStr ...
        '\t/* MAX ITERATION CHECK */\n' ...
        '\tif(it >= ' sprintf('%d', options.maxIt) ') {\n'];
    end
    repStr = [repStr ...
        '\t\tnIt[0] = it;\n' ...
        '\t\tt[0] = toc(&T);\n' ...
        '\t\tbreak;\n' ...
        '\t}\n' ...
        '\tit = it+1;\n'];
    if options.verbose >= 2
        repStr = [repStr '\tmexPrintf(''Consensus violation: %0.5g'', twonormsq(d, ' dim '));\n'];
    end
        repStr = [repStr '\t}'];
    code = regexprep(code, '(/. Final state ./.*\t\t\t})', repStr);
    f = fopen([options.gendir '/eprox.c'], 'w');
    fprintf(f, code);
    fclose(f);    
    
    if options.verbose >= 1
        display('C-code, done. Compiling...');
    end
    % Compile
    if options.verbose >= 2
        compile = 'mex -v';
    else
        compile = 'mex';
    end
    compile = [compile ' -I"' options.gendir '" CFLAGS="$CFLAGS -Wall" ' options.gendir '/eprox.c ' options.gendir '/timer.c'];
    for i=1:options.nr
        compile = [compile ' ' options.gendir '/stdproj' num2str(i) '.c'];
        compile = [compile ' ' options.gendir '/iniproj' num2str(i) '.c'];
        compile = [compile ' ' options.gendir '/finproj' num2str(i) '.c'];
    end
    compile = [compile ' -outdir ' options.gendir];
    display(compile);
    eval(compile);
    if options.verbose >= 1
        display('...done.');
    end

end

