% GENERATEPROXCODE Generate a fixed-point iteration .mex file
% 
% generateProxCode(model, 'par1', val1, 'par2', val2, ...)
% 

function generateProxCode(varargin)
    p = inputParser;
    p.addRequired('M', @isnumeric);
    p.addRequired('W', @isnumeric);
    p.addRequired('nr', @isnumeric);
    p.addParameter('stepSize', 0.5, @(x)(isnumeric(x) && x > 0 && x < 1));
    p.addParameter('maxIt', 1000, @(x)(isnumeric(x) && length(x) == 1 && x > 0 && mod(x,1) == 0)); % Maximum number of iterations
    p.addParameter('ctol', 1e-3, @(x)(isnumeric(x) && length(x) == 1 && x >= eps)); % Consensus tolerance
    p.addParameter('stoppingCriterion', 'consensus', @(s)(any(strcmp(s,{'consensus', 'maxIt'})))); % Stopping criterion
    p.addParameter('stopOnThreshold', true, @islogical);
    p.addParameter('gendir', './gen', @ischar);
    p.addParameter('verbose', 0, @isnumeric);
    p.addParameter('test', 0, @isnumeric);
    p.addParameter('solverName', 'hybridMPC', @ischar); % Name of generated solver
    p.parse(varargin{:});
    options = p.Results;
    
    if options.verbose >= 1
        display('Generating embedded fixed-point iteration...');
    end
    
    [Mdata, Mcode] = pcg.generateMVMult(options.M, [upper(options.solverName) '_M'], 'a', 'r', 'sym', true, 'nDataTabs', 0, 'nCodeTabs', 1);
    [gWdata, gWcode] = pcg.generateMVMult(options.stepSize*options.W, [upper(options.solverName) '_gW'], 'a', 'r', 'sym', true, 'nDataTabs', 0, 'nCodeTabs', 1);
    
    copyfile('+pcg/timer.h', [options.gendir '/timer.h']);
    f = fopen([options.gendir '/timer.h'], 'rt');
    code = fread(f, inf, 'char=>char');
    fclose(f);
    code = strrep(code', '#include "glblopts.h"', '#define PROFILING (1)\n\ntypedef double pfloat;\n');
    f = fopen([options.gendir '/timer.h'], 'w');
    fprintf(f, code);
    fclose(f);
    copyfile('+pcg/timer.c', [options.gendir '/timer.c']);
    
    % Generate fixed-point iteration C-file
    f = fopen([options.gendir '/project.h'], 'rt');
    code = fread(f, inf, 'char=>char');
    fclose(f);
    code = strrep(code', '_PROJECT_H_', ['_' upper(options.solverName) '_H_']);
    f = fopen([options.gendir '/' options.solverName '.h'], 'w');
    fprintf(f, code);
    fclose(f);
    f = fopen([options.gendir '/project.c'], 'rt');
    code = fread(f, inf, 'char=>char');
    fclose(f);
    dim = regexp(code', 'plhs... = mxCreateDoubleMatrix.(\d+),1,mxREAL.;', 'tokens');
    dim = dim{1}{1};
    n = str2num(dim);
    code = strrep(code', 'x', 's');
    code = strrep(code, 'project.h', [options.solverName '.h"\n#include "timer.h']);
    code = strrep(code, 'mes', 'mex');
    code = strrep(code, 'ms', 'mx');
    code = strrep(code, 'Matris', 'Matrix');
    code = strrep(code, 'double* s = mxGetPr', 'double* x = mxGetPr');
    data = [Mdata '\n\n' gWdata '\n\n'];
    code = strrep(code, '/* Helper functions */', ['timer T;\n\n' data '\n/* Helper functions */']);
    code = regexprep(code, '(/. Helper functions ./.*)\nvoid', ['$0 ' ...
        'vadd(double* a, double* b, unsigned int n, double* r) { /* r = a + b */\n' ...
        '\tunsigned int i;\n' ...
        '\tfor(i=0; i<n; i++) {\n' ...
        '\t\tr[i] = a[i]+b[i];' ...
        '\t}\n' ...
        '}\n' ...
        'void vsub(double* a, double* b, unsigned int n, double* r) { /* r = a - b */\n' ...
        '\tunsigned int i;\n' ...
        '\tfor(i=0; i<n; i++) {\n' ...
        '\t\tr[i] = a[i]-b[i];' ...
        '\t}\n' ...
        '}\n\n' ...
        'void mvmul' upper(options.solverName) '_M(double* a, unsigned int n, double* r) { /* r = r + ' upper(options.solverName) '_M*a */\n' ...
        Mcode ...
        '}\n' ...
        'void mvmul' upper(options.solverName) '_gW(double* a, unsigned int n, double* r) { /* r = r + ' upper(options.solverName) '_gW*a */\n' ...
        gWcode ...
        '}\n\n' ...
        'double twonormsq(double* a, unsigned int n) { /* |a|^2 */\n' ...
        '\tunsigned int i;\n' ...
        '\tdouble norm = 0.0;\n' ...
        '\tfor(i=0; i<n; i++) {\n' ...
        '\t\tnorm = norm + a[i]*a[i];' ...
        '\t}\n' ...
        '\treturn norm;\n' ...
        '}\n\n' ...
        'void']);
    code = strrep(code, 'double* theta = mxGetPr(prhs[1]);', 'double* theta = mxGetPr(prhs[1]);\n\tdouble* c = mxGetPr(prhs[2]);');
    code = strrep(code, ['plhs[0] = mxCreateDoubleMatrix(' dim ',1,mxREAL);'], ['plhs[0] = mxCreateDoubleMatrix(' dim ',1,mxREAL);\n\tplhs[1] = mxCreateDoubleMatrix(' dim ',1,mxREAL);\n\tplhs[2] = mxCreateDoubleMatrix(' dim ',1,mxREAL);\n\tplhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);\n\tplhs[4] = mxCreateDoubleMatrix(1,1,mxREAL);']);
    code = strrep(code, 'double* z = mxGetPr(plhs[0]);', ['double* y = mxGetPr(plhs[0]);\n\tdouble* z = mxGetPr(plhs[1]);\n\tdouble* s = mxGetPr(plhs[2]);\n\tdouble* nIt = mxGetPr(plhs[3]);\n\tdouble* t = mxGetPr(plhs[4]);\n\tdouble d[' dim '];']);
    code = strrep(code, '/* Initial state */', [ ...
        'unsigned int it = 1;\n' ...
        '\ttic(&T);\n' ...
        '\tvcopy(x, ' dim ', s);\n' ...
        '\twhile(1) {\n' ...
        '\t/* AFFINE MAP (1st step) */\n' ...
        '\tvcopy(c, ' dim ', y);/* y = c */\n' ...
        '\tmvmul' upper(options.solverName) '_M(s, ' dim ', y); /* y = y + Ms = Ms+c */\n\n' ...
        '\t/* PROJECTION (2nd step) */\n\t/* Initial state */']);
    repStr = ['$0\n\n' ...
        '\t/* S-UPDATE (3rd step) */\n' ...
        '\tvsub(z, y, ' dim ', d); /* d = z-y = -(y-z) */\n' ...
        '\tmvmul' upper(options.solverName) '_gW(d, ' dim ', s); /* s = s + gWd = s - gW(y-z) */\n' ...
        '\n'];
    switch options.stoppingCriterion
        case 'consensus',
            repStr = [repStr ...
            '\t/* CONSENSUS VIOLATION AND MAX ITERATION CHECK */\n' ...
            '\tif(twonormsq(d, ' dim ') <= ' sprintf('%0.10g', options.ctol^2) ' || it >= ' sprintf('%d', options.maxIt) ') {\n'];
        case 'maxIt'
            repStr = [repStr ...
            '\t/* MAX ITERATION CHECK */\n' ...
            '\tif(it >= ' sprintf('%d', options.maxIt) ') {\n'];
    end
    repStr = [repStr ...
        '\t\tnIt[0] = it;\n' ...
        '\t\tt[0] = toc(&T);\n' ...
        '\t\tbreak;\n' ...
        '\t}\n' ...
        '\tit = it+1;\n'];
    if options.verbose >= 2
        repStr = [repStr '\tmexPrintf(''Consensus violation: %0.5g'', twonormsq(d, ' dim '));\n'];
    end
        repStr = [repStr '\t}'];
    code = regexprep(code, '(/. Final state ./.*\t\t\t})', repStr);
    f = fopen([options.gendir '/' options.solverName '.c'], 'w');
    fprintf(f, code);
    fclose(f);    
    
    if options.verbose >= 1
        display('C-code, done. Compiling...');
    end
    % Compile
    if options.verbose >= 2
        compile = 'mex -v';
    else
        compile = 'mex';
    end
    compile = [compile ' -I"' options.gendir '" CFLAGS="$CFLAGS -Wall" ' options.gendir '/' options.solverName '.c ' options.gendir '/timer.c'];
    for i=1:options.nr
        compile = [compile ' ' options.gendir '/stdproj' num2str(i) '.c'];
        compile = [compile ' ' options.gendir '/iniproj' num2str(i) '.c'];
        compile = [compile ' ' options.gendir '/finproj' num2str(i) '.c'];
    end
    compile = [compile ' -outdir ' options.gendir];
    display(compile);
    eval(compile);
    if options.verbose >= 1
        display('...done.');
    end

end

